// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"

	"github.com/metal-stack/masterdata-api/api/v1"
	"github.com/metal-stack/masterdata-api/pkg/datastore"
	mock "github.com/stretchr/testify/mock"
)

// NewMockStorage creates a new instance of MockStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStorage[E datastore.Entity](t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStorage[E] {
	mock := &MockStorage[E]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStorage is an autogenerated mock type for the Storage type
type MockStorage[E datastore.Entity] struct {
	mock.Mock
}

type MockStorage_Expecter[E datastore.Entity] struct {
	mock *mock.Mock
}

func (_m *MockStorage[E]) EXPECT() *MockStorage_Expecter[E] {
	return &MockStorage_Expecter[E]{mock: &_m.Mock}
}

// Create provides a mock function for the type MockStorage
func (_mock *MockStorage[E]) Create(ctx context.Context, ve E) error {
	ret := _mock.Called(ctx, ve)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, E) error); ok {
		r0 = returnFunc(ctx, ve)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockStorage_Create_Call[E datastore.Entity] struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx context.Context
//   - ve E
func (_e *MockStorage_Expecter[E]) Create(ctx interface{}, ve interface{}) *MockStorage_Create_Call[E] {
	return &MockStorage_Create_Call[E]{Call: _e.mock.On("Create", ctx, ve)}
}

func (_c *MockStorage_Create_Call[E]) Run(run func(ctx context.Context, ve E)) *MockStorage_Create_Call[E] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 E
		if args[1] != nil {
			arg1 = args[1].(E)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_Create_Call[E]) Return(err error) *MockStorage_Create_Call[E] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_Create_Call[E]) RunAndReturn(run func(ctx context.Context, ve E) error) *MockStorage_Create_Call[E] {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockStorage
func (_mock *MockStorage[E]) Delete(ctx context.Context, id string) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockStorage_Delete_Call[E datastore.Entity] struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStorage_Expecter[E]) Delete(ctx interface{}, id interface{}) *MockStorage_Delete_Call[E] {
	return &MockStorage_Delete_Call[E]{Call: _e.mock.On("Delete", ctx, id)}
}

func (_c *MockStorage_Delete_Call[E]) Run(run func(ctx context.Context, id string)) *MockStorage_Delete_Call[E] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_Delete_Call[E]) Return(err error) *MockStorage_Delete_Call[E] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_Delete_Call[E]) RunAndReturn(run func(ctx context.Context, id string) error) *MockStorage_Delete_Call[E] {
	_c.Call.Return(run)
	return _c
}

// DeleteAll provides a mock function for the type MockStorage
func (_mock *MockStorage[E]) DeleteAll(ctx context.Context, ids ...string) error {
	var tmpRet mock.Arguments
	if len(ids) > 0 {
		tmpRet = _mock.Called(ctx, ids)
	} else {
		tmpRet = _mock.Called(ctx)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for DeleteAll")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ...string) error); ok {
		r0 = returnFunc(ctx, ids...)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_DeleteAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteAll'
type MockStorage_DeleteAll_Call[E datastore.Entity] struct {
	*mock.Call
}

// DeleteAll is a helper method to define mock.On call
//   - ctx context.Context
//   - ids ...string
func (_e *MockStorage_Expecter[E]) DeleteAll(ctx interface{}, ids ...interface{}) *MockStorage_DeleteAll_Call[E] {
	return &MockStorage_DeleteAll_Call[E]{Call: _e.mock.On("DeleteAll",
		append([]interface{}{ctx}, ids...)...)}
}

func (_c *MockStorage_DeleteAll_Call[E]) Run(run func(ctx context.Context, ids ...string)) *MockStorage_DeleteAll_Call[E] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []string
		var variadicArgs []string
		if len(args) > 1 {
			variadicArgs = args[1].([]string)
		}
		arg1 = variadicArgs
		run(
			arg0,
			arg1...,
		)
	})
	return _c
}

func (_c *MockStorage_DeleteAll_Call[E]) Return(err error) *MockStorage_DeleteAll_Call[E] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_DeleteAll_Call[E]) RunAndReturn(run func(ctx context.Context, ids ...string) error) *MockStorage_DeleteAll_Call[E] {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function for the type MockStorage
func (_mock *MockStorage[E]) Find(ctx context.Context, paging *v1.Paging, filters ...any) ([]E, *uint64, error) {
	var tmpRet mock.Arguments
	if len(filters) > 0 {
		tmpRet = _mock.Called(ctx, paging, filters)
	} else {
		tmpRet = _mock.Called(ctx, paging)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Find")
	}

	var r0 []E
	var r1 *uint64
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1.Paging, ...any) ([]E, *uint64, error)); ok {
		return returnFunc(ctx, paging, filters...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *v1.Paging, ...any) []E); ok {
		r0 = returnFunc(ctx, paging, filters...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]E)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *v1.Paging, ...any) *uint64); ok {
		r1 = returnFunc(ctx, paging, filters...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*uint64)
		}
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, *v1.Paging, ...any) error); ok {
		r2 = returnFunc(ctx, paging, filters...)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockStorage_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type MockStorage_Find_Call[E datastore.Entity] struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - ctx context.Context
//   - paging *v1.Paging
//   - filters ...any
func (_e *MockStorage_Expecter[E]) Find(ctx interface{}, paging interface{}, filters ...interface{}) *MockStorage_Find_Call[E] {
	return &MockStorage_Find_Call[E]{Call: _e.mock.On("Find",
		append([]interface{}{ctx, paging}, filters...)...)}
}

func (_c *MockStorage_Find_Call[E]) Run(run func(ctx context.Context, paging *v1.Paging, filters ...any)) *MockStorage_Find_Call[E] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *v1.Paging
		if args[1] != nil {
			arg1 = args[1].(*v1.Paging)
		}
		var arg2 []any
		var variadicArgs []any
		if len(args) > 2 {
			variadicArgs = args[2].([]any)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockStorage_Find_Call[E]) Return(vs []E, v *uint64, err error) *MockStorage_Find_Call[E] {
	_c.Call.Return(vs, v, err)
	return _c
}

func (_c *MockStorage_Find_Call[E]) RunAndReturn(run func(ctx context.Context, paging *v1.Paging, filters ...any) ([]E, *uint64, error)) *MockStorage_Find_Call[E] {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function for the type MockStorage
func (_mock *MockStorage[E]) Get(ctx context.Context, id string) (E, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 E
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (E, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) E); ok {
		r0 = returnFunc(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(E)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStorage_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockStorage_Get_Call[E datastore.Entity] struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockStorage_Expecter[E]) Get(ctx interface{}, id interface{}) *MockStorage_Get_Call[E] {
	return &MockStorage_Get_Call[E]{Call: _e.mock.On("Get", ctx, id)}
}

func (_c *MockStorage_Get_Call[E]) Run(run func(ctx context.Context, id string)) *MockStorage_Get_Call[E] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_Get_Call[E]) Return(v E, err error) *MockStorage_Get_Call[E] {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockStorage_Get_Call[E]) RunAndReturn(run func(ctx context.Context, id string) (E, error)) *MockStorage_Get_Call[E] {
	_c.Call.Return(run)
	return _c
}

// GetHistory provides a mock function for the type MockStorage
func (_mock *MockStorage[E]) GetHistory(ctx context.Context, id string, at time.Time, ve E) error {
	ret := _mock.Called(ctx, id, at, ve)

	if len(ret) == 0 {
		panic("no return value specified for GetHistory")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, time.Time, E) error); ok {
		r0 = returnFunc(ctx, id, at, ve)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_GetHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHistory'
type MockStorage_GetHistory_Call[E datastore.Entity] struct {
	*mock.Call
}

// GetHistory is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - at time.Time
//   - ve E
func (_e *MockStorage_Expecter[E]) GetHistory(ctx interface{}, id interface{}, at interface{}, ve interface{}) *MockStorage_GetHistory_Call[E] {
	return &MockStorage_GetHistory_Call[E]{Call: _e.mock.On("GetHistory", ctx, id, at, ve)}
}

func (_c *MockStorage_GetHistory_Call[E]) Run(run func(ctx context.Context, id string, at time.Time, ve E)) *MockStorage_GetHistory_Call[E] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		var arg3 E
		if args[3] != nil {
			arg3 = args[3].(E)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockStorage_GetHistory_Call[E]) Return(err error) *MockStorage_GetHistory_Call[E] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_GetHistory_Call[E]) RunAndReturn(run func(ctx context.Context, id string, at time.Time, ve E) error) *MockStorage_GetHistory_Call[E] {
	_c.Call.Return(run)
	return _c
}

// GetHistoryCreated provides a mock function for the type MockStorage
func (_mock *MockStorage[E]) GetHistoryCreated(ctx context.Context, id string, ve E) error {
	ret := _mock.Called(ctx, id, ve)

	if len(ret) == 0 {
		panic("no return value specified for GetHistoryCreated")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, E) error); ok {
		r0 = returnFunc(ctx, id, ve)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_GetHistoryCreated_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHistoryCreated'
type MockStorage_GetHistoryCreated_Call[E datastore.Entity] struct {
	*mock.Call
}

// GetHistoryCreated is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - ve E
func (_e *MockStorage_Expecter[E]) GetHistoryCreated(ctx interface{}, id interface{}, ve interface{}) *MockStorage_GetHistoryCreated_Call[E] {
	return &MockStorage_GetHistoryCreated_Call[E]{Call: _e.mock.On("GetHistoryCreated", ctx, id, ve)}
}

func (_c *MockStorage_GetHistoryCreated_Call[E]) Run(run func(ctx context.Context, id string, ve E)) *MockStorage_GetHistoryCreated_Call[E] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 E
		if args[2] != nil {
			arg2 = args[2].(E)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockStorage_GetHistoryCreated_Call[E]) Return(err error) *MockStorage_GetHistoryCreated_Call[E] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_GetHistoryCreated_Call[E]) RunAndReturn(run func(ctx context.Context, id string, ve E) error) *MockStorage_GetHistoryCreated_Call[E] {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockStorage
func (_mock *MockStorage[E]) Update(ctx context.Context, ve E) error {
	ret := _mock.Called(ctx, ve)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, E) error); ok {
		r0 = returnFunc(ctx, ve)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockStorage_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockStorage_Update_Call[E datastore.Entity] struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - ve E
func (_e *MockStorage_Expecter[E]) Update(ctx interface{}, ve interface{}) *MockStorage_Update_Call[E] {
	return &MockStorage_Update_Call[E]{Call: _e.mock.On("Update", ctx, ve)}
}

func (_c *MockStorage_Update_Call[E]) Run(run func(ctx context.Context, ve E)) *MockStorage_Update_Call[E] {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 E
		if args[1] != nil {
			arg1 = args[1].(E)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockStorage_Update_Call[E]) Return(err error) *MockStorage_Update_Call[E] {
	_c.Call.Return(err)
	return _c
}

func (_c *MockStorage_Update_Call[E]) RunAndReturn(run func(ctx context.Context, ve E) error) *MockStorage_Update_Call[E] {
	_c.Call.Return(run)
	return _c
}
